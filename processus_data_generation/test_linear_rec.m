% Script to synthesize a training and validation dataset for DeepMB.
[...
    output_root_folder,...
    path_to_rec_toolbox,...
    device_id,...
    speed_of_sound_range,...
    N,...
    field_of_view,...
    use_eir,...
    use_sir,...
    use_single_speed_of_sound,...
    filt_min,...
    filt_max,...
    num_cropped_samples_at_sinogram_start,...
    use_indiv_eir,...
    regularization,...
    lambda_shearlet,...
    lambda_tikhonov,...
    lambda_laplacian,...
    num_iterations_mb,...
    image_folder,...
    splits,...
    voc2012_start_indices_per_split,...
    num_considered_voc2012_imgs_per_split,...
    number_of_different_gt_sos_for_each_img_per_split,...
    use_gt_sos_also_as_rec_sos,...
    number_of_different_rec_sos_for_each_img_per_split,...
    random_sinogram_scaling,...
    max_scale_factor_for_initial_images,...
    path_to_invivo_sinograms_for_std_distr_estimation,...
    initial_img_transform,...
    path_to_studies_folders_with_raw_data,...
    data_name_prefix,...
    path_to_csv,...
    func_name_pulse_suffix,...
    broken_transducers,...
    use_all_sos_instead_of_only_gt_sos_for_invivo_rec] = set_parameters_for_data_generation();

%% Initialize reconstructions
run([path_to_rec_toolbox filesep 'startup_reconstruction.m']);
addpath(genpath('data_generation_utils'));
K = load_or_calculate_kernel_for_backprojection_rec(device_id);

%% Creating test image
% Image dimension
width = N(1);
height = N(2);

image = zeros(height, width); 

% Circles creation
centerY = round(height/(4/3));
centerX = round(width/(4/3));
lX = round(width/4);
rX = round(width/(4/3));

centerY_u = round(height/4);
ulY = round(width/4);
urY = round(width/2);


% Raggio del cerchio
radius = 8;

% Creazione del cerchio bianco
for row = 1:height
    for col = 1:width
        % Calculate the distance between the current pixel and the center of the image
        distance1 = sqrt((col - lX)^2 + (row - centerY)^2);
        distance2 = sqrt((col - centerX)^2 + (row - centerY)^2);
        distance3 = sqrt((col - rX)^2 + (row - centerY)^2);
        
        
        if distance1 <= radius || distance3 <= radius
            
            image(row, col) = 1;  
        end
        if distance2 <= radius
            image(row,col) = 1;
        end
        
        distance1_u = sqrt((col - lX)^2 + (row - centerY_u)^2);
        distance2_u = sqrt((col - centerY_u)^2 + (row - centerY_u)^2);
        distance3_u = sqrt((col - rX)^2 + (row - centerY_u)^2);
        
        if distance1_u <= radius || distance3_u <= radius || distance2_u <= radius
            image(row, col) = 1;
        end
        
    end
end
figure()
imagesc(image),colormap gray,title('target image')

%% %% Part 2: Generate sinograms, model-based images, and backprojection images for a singular value of sos

speed_of_sound = 1475;

fprintf('Generate model for speed of sound "%i".\n', speed_of_sound);
model = define_model_for_reconstruction(...
    field_of_view, N, device_id, use_eir, use_indiv_eir, use_sir, use_single_speed_of_sound, speed_of_sound,...
    num_cropped_samples_at_sinogram_start, filt_min, filt_max);


sinograms = model.Funcs.applyForward(image);
imagesc(sinograms), colormap gray, title('sinogram')

rec_imgs_bp = reconstruct_bp(model, K, sinograms);
figure()
imagesc(rec_imgs_bp), colormap gray, title('BP linear probe')


rec_imgs = reconstruct_model_based(model, sinograms, regularization, lambda_shearlet, lambda_tikhonov, lambda_laplacian, num_iterations_mb);
figure()
imagesc(rec_imgs), colormap gray, title('MB linear probe')